const intervals = {};

function runSubscription(namespace, roomName, loadDataFunction, options) {
    options = Object.assign({ timeout: 5000 }, options);

    return setInterval(() => {
        loadDataFunction().then(data => {
            console.log('send notification');
            namespace.to(roomName).emit('subscription', { data: data });
        });
    }, options.timeout);
}

module.exports = function(namespace) {
    function closeRoomIfEmpty(roomName) {
        if (!namespace.adapter.rooms[roomName]) { // will it work with redis? no... https://github.com/socketio/socket.io-redis/pull/15
            console.log(`room ${roomName} was removed`);
            clearInterval(intervals[roomName]);
            delete intervals[roomName];
        }
    }

    return function(roomName) {
        return {
            subscribe: function(socket, loadDataFunction, options) {
                return new Promise((resolve, reject) => {
                    if (socket.rooms[roomName]) { // documented as array... https://github.com/socketio/socket.io/issues/2495
                        return resolve();
                    }

                    socket.join(roomName, err => {
                        if (err) {
                            return reject(err);
                        }

                        if (!intervals[roomName]) {
                            intervals[roomName] = runSubscription(namespace, roomName, loadDataFunction, options);
                        }

                        loadDataFunction().then(data => {
                            socket.emit('update', { data: data }); // что если клиент уже отсоединился?
                        });

                        socket.on('disconnect', () => {
                            closeRoomIfEmpty(roomName);
                        });

                        resolve();
                    });
                });
            },

            unsubscribe: function(socket) {
                return new Promise((resolve, reject) => {
                    if (!socket.rooms[roomName]) {
                        return resolve();
                    }

                    socket.leave(roomName, err => {
                        if (err) {
                            return reject(err);
                        }

                        closeRoomIfEmpty(roomName);

                        resolve();
                    });
                });
            }
        };
    };
};